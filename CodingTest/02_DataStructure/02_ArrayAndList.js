// 자료구조 - 배열과 리스트
    
    //~ 배열
        /*
        가장 기본적인 자료구조다.
        여러 개의 변수를 담는 공간으로 이해할 수 있다.
        배열은 인덱스(index)가 존재하며, 인덱스는 0부터 시작한다.
        특정한 인덱스에 직접적으로 접근가능 → 수행시간 : O(1)
        */
    //~ 배열의 특징
        // 컴퓨터의 메인 메모리에서 배열의 공간은 연속적으로 할당된다.
        // 장점: 캐시(cache) 히트 가능성이 높으며, 조회가 빠르다.
        // 단점: 배열의 크기를 미리 지정해야 하는 것이 일반적이므로, 데이터의 추가 및 삭제에 한계가 있다.

        // 캐시 히트란 (ChatGPT)
        // 캐시히트(Cache Hit)란 컴퓨터에서 프로세서가 메모리에 접근할 때 
        // 캐시 메모리에서 원하는 데이터나 명령어가 이미 존재하여 빠르게 처리될 수 있는 경우를 말합니다. 
        // 이는 원래 데이터나 명령어를 메인 메모리나 하드 디스크에서 가져오는 것보다 훨씬 더 빠르게 처리할 수 있습니다. 
        // 따라서 캐시히트가 발생할 때는 시스템의 성능이 향상되며, 반대로 캐시미스(Cache Miss)가 발생하면 성능 저하가 일어날 수 있습니다.

    //~ 연결리스트(Linked List) - 참고
        // 연결 리스트는 컴퓨터의 메인 메모리상에서 주소가 연속적이지 않다.
        // 배열과 다르게 크기가 정해져 있지 않고, 리스트의 크기는 동적으로 변경 가능하다.
        // 장점: 포인터(pointer)를 통해 다음 데이터의 위치를 가리킨다는 점에서 삽입과 삭제가 간편하다. 
        // 단점: 특정 번째의 원소를 검색할 때는 앞에서부터 원소를 찾아야 하므로, 데이터 검색 속도가 느리다.

        // 연결리스트란 (ChatGPT)
        /*
            연결 리스트(Linked List)는 데이터 요소들이 순서대로 연결된 자료구조입니다. 
            각 요소는 데이터와 다음 요소를 가리키는 포인터(Pointer)로 구성되어 있습니다.
            연결 리스트는 배열과 달리 메모리 상에서 연속적으로 위치하지 않아도 되므로, 요소를 삽입하거나 삭제하는데 유리합니다. 
            예를 들어, 배열에서 요소를 삽입하거나 삭제할 경우, 해당 요소 이후의 모든 요소를 이동시켜야 하므로 시간이 오래 걸릴 수 있습니다. 
            반면에 연결 리스트에서는 해당 요소와 그 다음 요소만 연결을 수정하면 되기 때문에 이러한 문제가 발생하지 않습니다.
            연결 리스트는 단방향 연결 리스트(Singly Linked List)와 양방향 연결 리스트(Doubly Linked List)로 나뉘어지며, 각각의 특징은 다음과 같습니다.
                단방향 연결 리스트: 각 요소가 다음 요소를 가리키는 포인터만을 가지고 있으며, 이전 요소를 가리키는 포인터는 없습니다. 따라서, 순방향으로만 순회할 수 있습니다.
                양방향 연결 리스트: 각 요소가 이전 요소와 다음 요소를 가리키는 포인터를 모두 가지고 있습니다. 따라서, 양방향으로 순회할 수 있습니다.
            연결 리스트는 자료구조의 기초적인 형태 중 하나이며, 많은 알고리즘과 데이터 구조에서 활용됩니다.
        */

    // 배열과 연결리스트의 차이점
        // 1. 메모리 할당 방식
        // 2. 접근 속도
        // 3. 크기 변경
        // 4. 메모리 사용량
        // 5. 삽입과 삭제
        // 6. 정렬

        /*
            배열과 연결 리스트는 모두 데이터 요소들을 저장하는 자료구조입니다. 하지만 두 자료구조는 구현 방법과 특징이 다르기 때문에 각각의 장단점이 있습니다. 아래는 배열과 연결 리스트의 차이점입니다.

            메모리 할당 방식
                -배열은 데이터 요소들을 연속된 메모리 공간에 할당합니다. 따라서, 인덱스를 이용하여 빠르게 요소에 접근할 수 있습니다. 하지만 배열의 크기를 미리 정해야 하기 때문에, 크기를 변경하려면 새로운 배열을 생성하고 이전 배열의 요소들을 복사해야 합니다. 이는 크기가 큰 배열의 경우 시간이 오래 걸릴 수 있습니다.
                -반면에 연결 리스트는 데이터 요소들을 각각의 노드(Node)에 저장하고, 노드들은 포인터(Pointer)를 이용하여 서로 연결합니다. 따라서, 데이터 요소들이 연속된 메모리 공간에 할당되지 않기 때문에 크기를 미리 정하지 않아도 됩니다. 또한, 요소를 추가하거나 삭제할 때, 해당 노드와 연결된 포인터만 수정하면 되므로 배열보다 효율적입니다.
            접근 속도
                -배열은 인덱스를 이용하여 요소에 바로 접근할 수 있기 때문에, 접근 속도가 매우 빠릅니다. 반면에 연결 리스트는 요소를 차례대로 따라가야 하므로, 원하는 요소에 접근하기 위해서는 포인터를 따라 이동해야 합니다. 따라서, 배열보다 접근 속도가 느릴 수 있습니다.
            크기 변경
                -배열의 크기를 변경하려면, 새로운 배열을 생성하고 기존의 배열 요소들을 복사해야 합니다. 따라서, 크기가 큰 배열의 경우 크기 변경이 매우 비효율적입니다. 반면에 연결 리스트는 요소를 추가하거나 삭제할 때, 해당 노드와 연결된 포인터만 수정하면 되므로 크기 변경이 매우 쉽습니다.
            메모리 사용량
                -배열은 모든 요소를 저장하기 위해 미리 할당된 메모리 공간을 사용합니다. 따라서, 배열의 크기가 크면 메모리 사용량도 많아집니다. 반면에 연결 리스트는 필요한 만큼의 노드만을 할당하기 때문에 메모리 사용량이 상대적으로 적습니다.  
            삽입과 삭제
                -배열에서 중간에 요소를 추가하거나 삭제하면, 해당 위치 이후의 모든 요소들을 이동해야 하기 때문에 비용이 큽니다. 반면에 연결 리스트에서는 추가나 삭제가 간단합니다. 삽입할 위치의 이전 노드와 이후 노드 사이에 새로운 노드를 삽입하거나, 삭제할 노드의 이전 노드와 다음 노드의 연결을 끊어주면 됩니다.
            정렬
                -배열은 메모리에 연속해서 저장되어 있기 때문에 정렬이 쉽고 빠릅니다. 반면에 연결 리스트는 노드들이 포인터로 서로 연결되어 있기 때문에 정렬이 어렵고, 정렬 알고리즘을 구현하기 위해 추가적인 메모리를 사용해야 합니다.

            따라서, 배열은 인덱스를 이용하여 빠르게 요소에 접근할 수 있으며, 크기를 변경하는 일이 드물고, 정렬된 상태를 유지해야 할 때 유리합니다. 반면에 연결 리스트는 요소를 추가하거나 삭제할 때, 크기를 변경해야 하는 경우나, 요소들이 많이 추가되거나 삭제되는 경우에 유리합니다.
        */

    //~ JavaScript에서의 배열 
        //
        // 일반적인 프로그래밍 언어에서의 배열로 이해할 수 있다.
        // JavaScript의 배열은 일반 배열처럼 임의의 인덱스를 이용해 직접적인 접근이 가능하다.
        // JavaScript의 배열은 동적 배열의 기능을 제공하여, 맨 뒤의 위치에 원소 추가가 가능하다.
        // JavaScript의 배열 자료형은 동적 배열이다.
        // 배열의 용량이 가득 차면, 자동으로 크기를 증가시킨다.
        // 내부적으로 포인터(pointer)를 사용하여, 연결 리스트의 장점도 가지고 있다.
        //^ 배열(array) 혹은 스택(stack)의 기능이 필요할 때 사용할 수 있다. (in 코딩테스트)
        // [참고] 큐(queue)의 기능을 제공하지 못한다. (비효율적)

    //* 배열 초기화
        // 1) 대괄호 사용하기 - JavaScript에서는 대괄호를 이용해 간단히 배열을 생성할 수 있다.
            // 빈 배열 생성
            var arr = [];
            arr.push(7); arr.push(8); arr.push(9);
            for (let i = 0; i < arr.length; i++) {
            console.log(arr[i]);
            }
            
        // 2) Array() 사용하기 - JavaScript에서는 Array()를 이용해 간단히 배열을 생성할 수 있다.
            var arr = new Array();
            arr.push(7); arr.push(8); arr.push(9);
            for (let i = 0; i < arr.length; i++) {
            console.log(arr[i]);
            }

        // JavaScript의 배열은 일반적인 변수 외에도 객체를 담을 수도 있다.
            var arr = ["Hello", 777, true]; console.log(arr);

        // JavaScript에서는 임의의 크기를 가지는 배열을 만들 수 있다.
        // 원하는 값을 직접 입력하여 초기화 할 수 있다
        // 크기가 𝑁인 1차원 배열을 만드는 방법은 다음과 같다.

        // 원하는 값을 직접 입력하여 초기화
            var arr1 = [0, 1, 2, 3, 4];
            console.log(arr1);

        // 하나의 값으로 초기화
            var arr2 = Array.from({ length: 5 }, () => 7);
            console.log(arr2);

        //~ 크기가 N X M인 2차원 리스트(배열) 만들기 (1)
            // 원하는 값을 직접 입력하여 초기화
                var arr1 = [
                [0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]
                ];
                console.log(arr1);
        
        //~ 크기가 N X M인 2차원 리스트(배열) 만들기 (2)
            // 최신 JavaScript 환경(ES6 이상)에서 사용할 수 있는 문법이다.
            // 한줄로 2차원 배열을 초기화 할 수 있다.
            // 배열의 각 원소에 크기가 5인 배열을 할당한다.

            var arr = Array.from(Array(4), () => new Array(5))
            console.log(arr);

        //~ 크기가 N X M인 2차원 리스트(배열) 만들기 (3)
            // 다음과 같이 반복문을 이용해 2차원 배열을 초기화할 수 있다.
            // 반복문을 이용해 배열 초기화
                var arr2 = new Array(3);
                console.log('arr2: ', arr2);
                for (let i = 0; i < arr2.length; i++) {
                arr2[i] = Array.from(
                { length: 4 },
                (undefined, j) => i * 4 + j
                ); }
                console.log(arr2);


    //* JavaScript 배열 다루기
        // JavaScript의 배열은 동적 배열이다.
        // 배열이 생성된 이후에도 배열의 크기를 임의로 변경할 수 있다.
        // push() 메서드를 통해 배열의 가장 뒤쪽에 새로운 원소를 추가할 수 있다.
            var arr = [5, 6, 7, 8, 9]; arr.length = 8;
            arr[7] = 3;
            arr.push(1);
            for (let x of arr) {
            console.log(x);
            }

    //* JavaScript 배열의 대표적인 메서드
        // concat(): 여러 개의 배열을 이어 붙여서 합친 결과를 반환한다. 𝑂(𝑁)
        // slice(left, right): 특정 구간의 원소를 꺼낸 배열을 반환한다. 𝑂(𝑁)
        // indexOf(): 특정한 값을 가지는 원소의 첫째 인덱스를 반환한다. 𝑂(𝑁)



// 연결 리스트(Linked List)
    // 연결 리스트는 각 노드가 한 줄로 연결되어 있는 자료구조다.
    // 각 노드는 (데이터, 포인터) 형태를 가진다.
    // 포인터: 다음 노드의 메모리 주소를 가리키는 목적으로 사용된다.